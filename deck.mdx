import BwTheme from './themes/theme.js'
export const theme = BwTheme

import Preso from './layouts/default.js'
import { Grid, Box, Input, Button } from '@theme-ui/components'


<Preso>

# Bloom Filters and Offheap Java Memory
### _By Dan Goslen_

</Preso>

---

<Preso>

# What Are Bloom Filters?

> _In-memory probablistic data structure that can say if a key either does **NOT** exist in a set, or that it **MIGHT** exist in the set_

</Preso>

---

<Preso>

# What Do They Do?
* **Protect** more expensive resources
  * Like databases or files
* ie - performing lookups against a relatively small data set

</Preso>

---

<Preso>

# How to Use?
* Construct a filter for a set in the more expensive resource
  * Will refer to this as the "target set"
* Add each key from the target set to the filter
* When performing a lookup, check filter before the target set

</Preso>

---

<Preso>

# Remember Hashing?
* Given key `k`, calculate `h(k)`
* Use resulting `h` to find a value in a table of size `m`
* Looking up a key performs the same `h(k)` to check for the presence of the key

</Preso>

---


<Preso>

# Bloom Filters Use Multiple Hahses
* Table is a bit array
* Calculate different hash values fot each key `k`
* Mark each bit in the array at the hash value to `1`

</Preso>

---

<Preso>

# Inserting a Key `k`
* `m` size of bit array; `i` number of hashes
* Calculate `i` hashes for `k`
* For each hash value, find its position within the bit array and set it to 1

</Preso>

---

<Preso>

# Might Contain a Key `k`
* Calculate the **same** `i` hash values
* Check each position in the bit array for each hash values
* Logical `&` of each bit position
* If `true`, the `k` **might** exist in the set

</Preso>

---

<Preso>

# Probablistic
* Overtime and with many keys, bit array will have many bits set to `1`
* Many bit positions were set from different keys
* Will get false positives for candidate keys

<Grid
  gap={2}
  columns={[2, '1fr 3fr']}>

<Box/>

<Box style={{ textAlign: 'center' }}>Predicted</Box>

<Box style={{ textAlign: 'center', verticalAlign: 'middle', lineHeight: '160px' }}>Actual</Box>

<Grid
  gap={2}
  columns={[2, '1fr 1fr']}>

  <Box style={{ textAlign: 'center' }} bg='#4d8d7c'>True Negative</Box>
  <Box style={{ textAlign: 'center' }} bg='#9d390a'>False Positive</Box>
  <Box style={{ textAlign: 'center' }} bg='#4d2966'>False Negative</Box>
  <Box style={{ textAlign: 'center' }} bg='#4d8d7c'>True Positive</Box>
</Grid>

</Grid>

<Box style={{ marginTop: '80px', marginLeft: 'auto', marginRight: 'auto', width: '900px' }}>To reduce False Positives, combination of growing table and increasing <i>i</i></Box>

</Preso>

---

import { State, Observe } from 'mdx-observable'

<State
  initialState={{
    bits: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    size: 13,
    checked: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    check: false,
    clean: true,
  }}>

<Observe>
  { ({ checked, clean }) => (
    <Box style={{ marginBottom: "30px" }}> {
      checked.map(v => (<div style={{ display: 'inline-block', textAlign: 'center', marginRight: '10px', height: '20px', width: '35px' }}>{ (v == 1 && !clean) ? '‚¨áÔ∏è' : ' ' }</div>))}
    </Box>
  ) }
</Observe>

<Observe>
  { ({ bits }) => (
    <Box style={{ marginBottom: "30px" }}> {
      bits.map(v => (<div style={{ display: 'inline-block', textAlign: 'center', marginRight: '10px', height: '20px', width: '35px' }}>{ v }</div>))}
    </Box>
  ) }
</Observe>

<Observe>
  { ({ bits, size, setState }) =>
    (
        <form onSubmit={ e => {
          e.preventDefault();
          var name = document.getElementById("name").value;
          var hash = 0;
          for (var i = 0; i < name.length; i++) {
            var c = name.charCodeAt(i);
            hash = ((hash << 5) - hash) + c;
            hash = hash & hash;
          }
          var idx = hash % size;
          if (idx < 0) {
            idx = idx * -1;
          }
          var updated = bits;
          updated[idx] = 1;
          hash = 0;
          for (var i = 0; i < name.length; i++) {
            var c = name.charCodeAt(i);
            hash = ((hash << 4) - hash) + c;
            hash = hash & hash;
          }
          idx = hash % size;
          if (idx < 0) {
            idx = idx * -1;
          }
          updated[idx] = 1;
          setState(s => ({ ...s, bits: updated }));
          document.getElementById("name").value = '';
        }} style={{ width: '100%'}} >
            <Input style={{ display: 'inline-block', width: '30%', marginLeft: '15%', marginRight: '5%' }} id="name" type="text" />
            <Button bg='#4d8d7c' style={{ color: '#3e2f37', display: 'inline-block', width: '30%', marginLeft: '5%' }} type="submit">Add Name</Button>
        </form>
  ) }
</Observe>

<Observe>
  { ({ bits, checked, size, setState }) =>
    (
        <form onSubmit={ e => {
          e.preventDefault();
          var name = document.getElementById("check").value;
          var hash = 0;
          for (var i = 0; i < name.length; i++) {
            var c = name.charCodeAt(i);
            hash = ((hash << 5) - hash) + c;
            hash = hash & hash;
          }
          var idx = hash % size;
          if (idx < 0) {
            idx = idx * -1;
          }
          var updated = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          updated[idx] = 1;
          hash = 0;
          for (var i = 0; i < name.length; i++) {
            var c = name.charCodeAt(i);
            hash = ((hash << 4) - hash) + c;
            hash = hash & hash;
          }
          idx = hash % size;
          if (idx < 0) {
            idx = idx * -1;
          }
          updated[idx] = 1;
          setState(s => ({ ...s, check: bits[idx] == 1, clean: false, checked: updated }));
          document.getElementById("check").value = '';
        }} style={{ width: '100%'}} >
            <Input style={{ display: 'inline-block', width: '30%', marginLeft: '15%', marginRight: '5%' }} id="check" type="text" />
            <Button bg='#005c44' style={{ color: '#3e2f37', display: 'inline-block', width: '30%', marginLeft: '5%' }} type="submit">Check Name</Button>
        </form>
  ) }
</Observe>

<Observe>
  { ({ clean, size, check, setState }) => (
      <div onClick={ e => {
        setState(s => ({ ...s, clean: true }));
      }} style={{ width: '15px', height: '15px' }} >
        { clean ? ' ' : check ? 'ü§∑‚Äç‚ôÇÔ∏è' : '‚ùå' }
      </div>
  ) }
</Observe>

</State>

---

<Preso>

# Use Case: Telephone Numbers
* Blacklists (used for blocking calls) are literally just lists of numbers
* These lists are **much** smaller than the total count of numbers that could go through Roger
* Lists are still too large to stay in memory, and need to be persisted

</Preso>

---

<Preso>

# Bloom Filters are (Relativley) Small
* Bloom Filters only need a small amount of memory relative to the size of the set that built it
* ex: Blacklist of 3 million entries ~36 Mb; Bloom Filter is ~2.3 Mb for with 95% false positive

</Preso>

---

<Preso>

# Bloom Filters are Constrainable
* You can have a _really_ small bloom filter if you want
* Simply pay the cost in increased false positives

</Preso>

---

import { FullScreenCode } from 'mdx-deck'
import BloomFilter from './images/bloom_filter.png'

<Preso>

<div style={{ width: '80%', margin: 'auto' }}>
  <img src={BloomFilter} />
</div>

</Preso>

---

---

## The End
